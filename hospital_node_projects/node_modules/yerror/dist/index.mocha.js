"use strict";

var _assert = _interopRequireDefault(require("assert"));

var _ = _interopRequireDefault(require("."));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint max-nested-callbacks:[0], no-magic-numbers:[0] */
describe('YError', () => {
  describe('.__constructor', () => {
    it('Should work', () => {
      var err = new _.default('E_ERROR', 'arg1', 'arg2');
      (0, _assert.default)(err instanceof Error);

      _assert.default.equal(err.name, err.toString());

      _assert.default.equal(err.code, 'E_ERROR');

      _assert.default.deepEqual(err.params, ['arg1', 'arg2']);

      _assert.default.equal(err.toString(), 'YError: E_ERROR (arg1, arg2)');
    });
    it('Should work without code', () => {
      var err = new _.default();

      _assert.default.equal(err.code, 'E_UNEXPECTED');

      _assert.default.deepEqual(err.params, []);

      _assert.default.equal(err.toString(), 'YError: E_UNEXPECTED ()');

      _assert.default.equal(err.name, err.toString());
    });
    it('Should work without new', () => {
      var err = new _.default('E_ERROR', 'arg1', 'arg2');

      _assert.default.equal(err.code, 'E_ERROR');

      (0, _assert.default)(err instanceof _.default);

      _assert.default.deepEqual(err.params, ['arg1', 'arg2']);

      _assert.default.equal(err.toString(), 'YError: E_ERROR (arg1, arg2)');

      _assert.default.equal(err.name, err.toString());
    });
  });
  describe('.wrap()', () => {
    it('Should work with standard errors and a message', () => {
      // eslint-disable-line
      var err = _.default.wrap(new Error('This is an error!'));

      _assert.default.equal(err.code, 'E_UNEXPECTED');

      _assert.default.equal(err.wrappedErrors.length, 1);

      _assert.default.deepEqual(err.params, ['This is an error!']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: This is an error!'), 'Stack contains original error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_UNEXPECTED (This is an error!)'), 'Stack contains cast error.');

        _assert.default.equal(err.name, err.toString());
      }
    });
    it('Should work with standard errors and an error code', () => {
      var err = _.default.wrap(new Error('E_ERROR'));

      _assert.default.equal(err.code, 'E_ERROR');

      _assert.default.equal(err.wrappedErrors.length, 1);

      _assert.default.deepEqual(err.params, []);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: E_ERROR'), 'Stack contains original error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR ()'), 'Stack contains cast error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
    it('Should work with standard errors, an error code and params', () => {
      var err = _.default.wrap(new Error('E_ERROR'), 'E_ERROR_2', 'arg1', 'arg2');

      _assert.default.equal(err.code, 'E_ERROR_2');

      _assert.default.equal(err.wrappedErrors.length, 1);

      _assert.default.deepEqual(err.params, ['arg1', 'arg2']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: E_ERROR'), 'Stack contains first error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR_2 (arg1, arg2)'), 'Stack contains second error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
    it('Should work with several wrapped errors', () => {
      var err = _.default.wrap(_.default.wrap(new Error('E_ERROR_1'), 'E_ERROR_2', 'arg2.1', 'arg2.2'), 'E_ERROR_3', 'arg3.1', 'arg3.2');

      _assert.default.equal(err.code, 'E_ERROR_3');

      _assert.default.equal(err.wrappedErrors.length, 2);

      _assert.default.deepEqual(err.params, ['arg3.1', 'arg3.2']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: E_ERROR_1'), 'Stack contains first error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR_2 (arg2.1, arg2.2)'), 'Stack contains second error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR_3 (arg3.1, arg3.2)'), 'Stack contains second error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
  });
  describe('.cast()', () => {
    it('Should work with standard errors and a message', () => {
      var err = _.default.cast(new Error('This is an error!'));

      _assert.default.equal(err.code, 'E_UNEXPECTED');

      _assert.default.equal(err.wrappedErrors.length, 1);

      _assert.default.deepEqual(err.params, ['This is an error!']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: This is an error!'), 'Stack contains original error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_UNEXPECTED (This is an error!)'), 'Stack contains cast error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
    it('Should let YError instances pass through', () => {
      var err = _.default.cast(new _.default('E_ERROR', 'arg1', 'arg2'));

      _assert.default.equal(err.code, 'E_ERROR');

      _assert.default.deepEqual(err.params, ['arg1', 'arg2']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR (arg1, arg2)'), 'Stack contains cast error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
  });
  describe('.bump()', () => {
    it('Should work with standard errors and a message', () => {
      var err = _.default.bump(new Error('This is an error!'));

      _assert.default.equal(err.code, 'E_UNEXPECTED');

      _assert.default.equal(err.wrappedErrors.length, 1);

      _assert.default.deepEqual(err.params, ['This is an error!']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: This is an error!'), 'Stack contains original error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_UNEXPECTED (This is an error!)'), 'Stack contains bumped error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
    it('Should work with YError like errors', () => {
      var baseErr = new Error('E_A_NEW_ERROR');
      baseErr.code = 'E_A_NEW_ERROR';
      baseErr.params = ['baseParam1', 'baseParam2'];

      let err = _.default.bump(baseErr);

      _assert.default.equal(err.code, 'E_A_NEW_ERROR');

      _assert.default.equal(err.wrappedErrors.length, 1);

      _assert.default.deepEqual(err.params, ['baseParam1', 'baseParam2']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('Error: E_A_NEW_ERROR'), 'Stack contains original error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_A_NEW_ERROR (baseParam1, baseParam2)'), 'Stack contains bumped error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
    it('Should work with Y errors and a message', () => {
      var err = _.default.bump(new _.default('E_ERROR', 'arg1.1', 'arg1.2'), 'E_ERROR_2', 'arg2.1', 'arg2.2');

      _assert.default.equal(err.code, 'E_ERROR');

      _assert.default.deepEqual(err.params, ['arg1.1', 'arg1.2']);

      if (Error.captureStackTrace) {
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR (arg1.1, arg1.2)'), 'Stack contains original error.');
        (0, _assert.default)(-1 !== err.stack.indexOf('YError: E_ERROR (arg1.1, arg1.2)'), 'Stack contains bumped error.');
      }

      _assert.default.equal(err.name, err.toString());
    });
  });
});
//# sourceMappingURL=index.mocha.js.map