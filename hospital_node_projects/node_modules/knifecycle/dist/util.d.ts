export declare const DECLARATION_SEPARATOR = ">";
export declare const OPTIONAL_FLAG = "?";
export declare const ALLOWED_INITIALIZER_TYPES: readonly ["provider", "service", "constant"];
export declare type ServiceName = string;
export declare type Service = any;
export interface Disposer {
    (): Promise<void>;
}
export declare type FatalErrorPromise = Promise<void>;
export declare type Provider<S extends Service> = {
    service: S;
    dispose?: Disposer;
    fatalErrorPromise?: FatalErrorPromise;
};
export declare type Dependencies<S extends Service = Service> = {
    [name: string]: S;
};
export declare type DependencyName = string;
export declare type DependencyDeclaration = string;
export declare type ExtraInformations = any;
export declare type ParsedDependencyDeclaration = {
    serviceName: string;
    mappedName: string;
    optional: boolean;
};
export declare type ConstantProperties = {
    $type: 'constant';
    $name: DependencyName;
    $singleton: true;
};
export declare type ConstantInitializer<S extends Service> = ConstantProperties & {
    $value: S;
};
export declare type ProviderInitializerBuilder<D extends Dependencies, S extends Service> = ((dependencies: D) => Promise<Provider<S>>) | ((dependencies?: D) => Promise<Provider<S>>);
export declare type ProviderProperties = {
    $type: 'provider';
    $name: DependencyName;
    $inject?: DependencyDeclaration[];
    $singleton?: boolean;
    $extra?: ExtraInformations;
};
export declare type ProviderInitializer<D extends Dependencies, S extends Service> = ((dependencies: D) => Promise<Provider<S>>) | ((dependencies?: D) => Promise<Provider<S>>);
export declare type ProviderInputProperties = {
    type: 'provider';
    name: DependencyName;
    inject?: DependencyDeclaration[];
    singleton?: boolean;
    extra?: ExtraInformations;
};
export declare type ServiceInitializerBuilder<D extends Dependencies, S extends Service> = ((dependencies: D) => Promise<S>) | ((dependencies?: D) => Promise<S>);
export declare type ServiceProperties = {
    $type: 'service';
    $name: DependencyName;
    $inject?: DependencyDeclaration[];
    $singleton?: boolean;
    $extra?: ExtraInformations;
};
export declare type ServiceInitializer<D extends Dependencies, S extends Service> = ((dependencies: D) => Promise<S>) | ((dependencies?: D) => Promise<S>);
export declare type ServiceInputProperties = {
    type: 'service';
    name: DependencyName;
    inject?: DependencyDeclaration[];
    singleton?: boolean;
    extra?: ExtraInformations;
};
export declare type InitializerProperties = ConstantProperties | ProviderProperties | ServiceProperties;
export declare type AsyncInitializerBuilder<D extends Dependencies, S extends Service> = ProviderInitializerBuilder<D, S> | ServiceInitializerBuilder<D, S>;
export declare type AsyncInitializer<D extends Dependencies, S extends Service> = ServiceInitializer<D, S> | ProviderInitializer<D, S>;
export declare type PartialAsyncInitializer<D extends Dependencies, S extends Service> = Partial<ServiceInitializer<D, S>> | Partial<ProviderInitializer<D, S>>;
export declare type Initializer<S extends Service, D extends Dependencies> = ConstantInitializer<S> | ServiceInitializer<D, S> | ProviderInitializer<D, S>;
export declare type ServiceInitializerWrapper<S extends Service, D extends Dependencies> = (dependencies: D, baseService: S) => Promise<S>;
export declare type ProviderInitializerWrapper<S extends Service, D extends Dependencies> = (dependencies: D, baseService: Provider<S>) => Promise<Provider<S>>;
export declare type Parameters<V = any> = {
    [name: string]: V;
};
export declare type HandlerFunction<D extends Dependencies, V, P extends Parameters<V>, U extends any[], R> = ((dependencies: D, parameters: P, ...args: U) => Promise<R>) | ((dependencies: D, parameters?: P, ...args: U) => Promise<R>);
export declare const SPECIAL_PROPS_PREFIX = "$";
export declare const SPECIAL_PROPS: {
    TYPE: string;
    NAME: string;
    INJECT: string;
    SINGLETON: string;
    EXTRA: string;
    VALUE: string;
};
export declare const ALLOWED_SPECIAL_PROPS: any[];
export declare function parseInjections(source: string, options?: {
    allowEmpty: boolean;
}): DependencyDeclaration[];
export declare function readFunctionName(aFunction: Function): string;
export declare function parseName(functionName: string): string;
/**
 * Apply special props to the given initializer from another one
 *  and optionally amend with new special props
 * @param  {Function} from The initializer in which to pick the props
 * @param  {Function} to   The initializer from which to build the new one
 * @param  {Object}   [amend={}]   Some properties to override
 * @return {Function}      The newly built initializer
 */
export declare function reuseSpecialProps<FD, TD, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ProviderInitializerBuilder<TD, S>, amend?: Partial<ProviderProperties>): ProviderInitializerBuilder<FD & TD, S>;
export declare function reuseSpecialProps<FD, TD, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ServiceInitializerBuilder<TD, S>, amend?: Partial<ServiceProperties>): ServiceInitializerBuilder<FD & TD, S>;
/**
 * Decorator that creates an initializer for a constant value
 * @param  {String}    name
 * The constant's name.
 * @param  {any}  value
 * The constant's value
 * @return {Function}
 * Returns a new constant initializer
 * @example
 * import Knifecycle, { constant, service } from 'knifecycle';
 *
 * const { printAnswer } = new Knifecycle()
 *   .register(constant('THE_NUMBER', value))
 *   .register(constant('log', console.log.bind(console)))
 *   .register(service(
 *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
 *     'printAnswer',
 *     ['THE_NUMBER', 'log'],
 *   ))
 *   .run(['printAnswer']);
 *
 * printAnswer(); // 42
 */
export declare function constant<V extends Service>(name: DependencyName, value: V): ConstantInitializer<V>;
/**
 * Decorator that creates an initializer from a service builder
 * @param  {Function}   serviceBuilder
 * An async function to build the service
 * @param  {String}    [name]
 * The service's name
 * @param  {Array<String>}    [dependencies]
 * The service's injected dependencies
 * @param  {Boolean}    [singleton]
 * Whether the service is a singleton or not
 * @param  {any}    [extra]
 * Eventual extra informations
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { constant, service } from 'knifecycle';
 *
 * const { printAnswer } = new Knifecycle()
 *   .register(constant('THE_NUMBER', value))
 *   .register(constant('log', console.log.bind(console)))
 *   .register(service(
 *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
 *     'printAnswer',
 *     ['THE_NUMBER', 'log'],
 *     true
 *   ))
 *   .run(['printAnswer']);
 *
 * printAnswer(); // 42
 */
export declare function service<D, S>(serviceBuilder: ServiceInitializerBuilder<D, S>, name?: DependencyName, dependencies?: DependencyDeclaration[], singleton?: boolean, extra?: ExtraInformations): ServiceInitializer<D, S>;
/**
 * Decorator that creates an initializer from a service
 *  builder by automatically detecting its name
 *  and dependencies
 * @param  {Function}   serviceBuilder
 * An async function to build the service
 * @return {Function}
 * Returns a new initializer
 */
export declare function autoService<D, S>(serviceBuilder: ServiceInitializerBuilder<D, S>): ServiceInitializer<D, S>;
/**
 * Decorator that creates an initializer for a provider
 *  builder
 * @param  {Function} providerBuilder
 * An async function to build the service provider
 * @param  {String} [name]
 * The service's name
 * @param  {Array<String>} [dependencies]
 * The service's dependencies
 * @param  {Boolean} [singleton]
 * Whether the service is a singleton or not
 * @param  {any} [extra]
 * Eventual extra informations
 * @return {Function}
 * Returns a new provider initializer
 * @example
 *
 * import Knifecycle, { provider } from 'knifecycle'
 * import fs from 'fs';
 *
 * const $ = new Knifecycle();
 *
 * $.register(provider(configProvider, 'config'));
 *
 * async function configProvider() {
 *   return new Promise((resolve, reject) {
 *     fs.readFile('config.js', function(err, data) {
 *       let config;
 *
 *       if(err) {
 *         reject(err);
 *         return;
 *       }
 *
 *       try {
 *         config = JSON.parse(data.toString);
 *       } catch (err) {
 *         reject(err);
 *         return;
 *       }
 *
 *       resolve({
 *         service: config,
 *       });
 *     });
 *   });
 * }
 */
export declare function provider<D, S>(providerBuilder: ProviderInitializerBuilder<D, S>, name?: DependencyName, dependencies?: DependencyDeclaration[], singleton?: boolean, extra?: ExtraInformations): ProviderInitializer<D, S>;
/**
 * Decorator that creates an initializer from a provider
 *  builder by automatically detecting its name
 *  and dependencies
 * @param  {Function}   providerBuilder
 * An async function to build the service provider
 * @return {Function}
 * Returns a new provider initializer
 */
export declare function autoProvider<D, S>(providerBuilder: ProviderInitializerBuilder<D, S>): ProviderInitializer<D, S>;
/**
 * Allows to wrap an initializer to add extra initialization steps
 * @param  {Function} wrapper
 * A function taking dependencies and the base
 * service in arguments
 * @param  {Function} baseInitializer
 * The initializer to decorate
 * @return {Function}
 * The new initializer
 */
export declare function wrapInitializer<D, S>(wrapper: ProviderInitializerWrapper<S, D>, baseInitializer: ProviderInitializer<D, S>): ProviderInitializer<D, S>;
export declare function wrapInitializer<D, S>(wrapper: ServiceInitializerWrapper<S, D>, baseInitializer: ServiceInitializer<D, S>): ServiceInitializer<D, S>;
/**
 * Decorator creating a new initializer with different
 *  dependencies declarations set to it.
 * @param  {Array<String>}  dependencies
 * List of dependencies declarations to declare which
 *  services the initializer needs to provide its
 *  own service
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { inject } from 'knifecycle'
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 *  .register(
 *    service(
 *      inject(['ENV'], myServiceInitializer)
 *      'myService',
 *    )
 *   )
 * );
 */
export declare function inject<D, S>(dependencies: DependencyDeclaration[], initializer: ProviderInitializer<any, S>): ProviderInitializer<D, S>;
export declare function inject<D, S>(dependencies: DependencyDeclaration[], initializer: ProviderInitializerBuilder<any, S>): ProviderInitializerBuilder<D, S>;
export declare function inject<D, S>(dependencies: DependencyDeclaration[], initializer: ServiceInitializer<any, S>): ServiceInitializer<D, S>;
export declare function inject<D, S>(dependencies: DependencyDeclaration[], initializer: ServiceInitializerBuilder<any, S>): ServiceInitializerBuilder<D, S>;
/**
 * Apply injected dependencies from the given initializer to another one
 * @param  {Function} from The initialization function in which to pick the dependencies
 * @param  {Function} to   The destination initialization function
 * @return {Function}      The newly built initialization function
 */
export declare function useInject<FD, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ProviderInitializer<Dependencies, S>): ProviderInitializer<FD, S>;
export declare function useInject<FD, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ProviderInitializerBuilder<Dependencies, S>): ProviderInitializerBuilder<FD, S>;
export declare function useInject<FD, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ServiceInitializer<Dependencies, S>): ServiceInitializer<FD, S>;
export declare function useInject<FD, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ServiceInitializerBuilder<Dependencies, S>): ServiceInitializerBuilder<FD, S>;
/**
 * Merge injected dependencies of the given initializer with another one
 * @param  {Function} from The initialization function in which to pick the dependencies
 * @param  {Function} to   The destination initialization function
 * @return {Function}      The newly built initialization function
 */
export declare function mergeInject<FD, D, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ProviderInitializer<D, S>): ProviderInitializer<FD & D, S>;
export declare function mergeInject<FD, D, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ProviderInitializerBuilder<D, S>): ProviderInitializerBuilder<FD & D, S>;
export declare function mergeInject<FD, D, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ServiceInitializer<D, S>): ServiceInitializer<FD, S>;
export declare function mergeInject<FD, D, S>(from: AsyncInitializerBuilder<FD, unknown> | PartialAsyncInitializer<FD, unknown>, to: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<FD, S>;
/**
 * Decorator creating a new initializer with different
 *  dependencies declarations set to it according to the
 *  given function signature.
 * @param  {Function}  initializer
 * The original initializer
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { autoInject, name } from 'knifecycle'
 *
 * new Knifecycle()
 *   .register(
 *     name(
 *       'application',
 *       autoInject(
 *         async ({ NODE_ENV, mysql: db }) =>
 *           async () => db.query('SELECT applicationId FROM applications WHERE environment=?', [NODE_ENV])
 *         )
 *       )
 *     )
 *   )
 * );
 */
export declare function autoInject<D, S>(initializer: ProviderInitializer<D, S>): ProviderInitializer<D, S>;
export declare function autoInject<D, S>(initializer: ProviderInitializerBuilder<D, S>): ProviderInitializerBuilder<D, S>;
export declare function autoInject<D, S>(initializer: ServiceInitializer<D, S>): ServiceInitializer<D, S>;
export declare function autoInject<D, S>(initializer: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<D, S>;
/**
 * Decorator creating a new initializer with some
 *  more dependencies declarations appended to it.
 * @param  {Array<String>}  dependencies
 * List of dependencies declarations to append
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { alsoInject } from 'knifecycle'
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(service(
 *   alsoInject(['ENV'], myServiceInitializer),
 *   'myService',
 * ));
 */
export declare function alsoInject<ND, D, S>(dependencies: DependencyDeclaration[], to: ProviderInitializer<D, S>): ProviderInitializer<ND & D, S>;
export declare function alsoInject<ND, D, S>(dependencies: DependencyDeclaration[], to: ProviderInitializerBuilder<D, S>): ProviderInitializerBuilder<ND & D, S>;
export declare function alsoInject<ND, D, S>(dependencies: DependencyDeclaration[], to: ServiceInitializer<D, S>): ServiceInitializer<ND & D, S>;
export declare function alsoInject<ND, D, S>(dependencies: DependencyDeclaration[], to: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<ND & D, S>;
/**
 * Decorator creating a new initializer with some
 *  extra informations appended to it. It is just
 *  a way for user to store some additional
 *  informations but has no interaction with the
 *  Knifecycle internals.
 * @param  {Object}  extraInformations
 * An object containing those extra informations.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @param  {Boolean}   [merge=false]
 * Whether the extra object should be merged
 * with the existing one or not
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { extra } from 'knifecycle'
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(service(
 *   extra({ httpHandler: true }, myServiceInitializer),
 *   'myService',
 * ));
 */
export declare function extra<D, S>(extraInformations: ExtraInformations, initializer: ProviderInitializer<D, S>, merge?: boolean): ProviderInitializer<D, S>;
export declare function extra<D, S>(extraInformations: ExtraInformations, initializer: ProviderInitializerBuilder<D, S>, merge?: boolean): ProviderInitializerBuilder<D, S>;
export declare function extra<D, S>(extraInformations: ExtraInformations, initializer: ServiceInitializer<D, S>): ServiceInitializer<D, S>;
export declare function extra<D, S>(extraInformations: ExtraInformations, initializer: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<D, S>;
/**
 * Decorator to set an initializer singleton option.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @param  {boolean}    [isSingleton=true]
 * Define the initializer singleton option
 * (one instance for several runs if true)
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { inject, singleton } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(service(
 *   inject(['ENV'],
 *     singleton(myServiceInitializer)
 *   ),
 *   'myService',
 * ));
 */
export declare function singleton<D, S>(initializer: ProviderInitializer<D, S>, isSingleton?: boolean): ProviderInitializer<D, S>;
export declare function singleton<D, S>(initializer: ProviderInitializerBuilder<D, S>, isSingleton?: boolean): ProviderInitializerBuilder<D, S>;
export declare function singleton<D, S>(initializer: ServiceInitializer<D, S>, isSingleton?: boolean): ServiceInitializer<D, S>;
export declare function singleton<D, S>(initializer: ServiceInitializerBuilder<D, S>, isSingleton?: boolean): ServiceInitializerBuilder<D, S>;
/**
 * Decorator to set an initializer name.
 * @param  {String}    name
 * The name of the service the initializer resolves to.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer with that name set
 * @example
 *
 * import Knifecycle, { name } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(name('myService', myServiceInitializer));
 */
export declare function name<D, S>(name: DependencyName, initializer: ProviderInitializer<D, S>): ProviderInitializer<D, S>;
export declare function name<D, S>(name: DependencyName, initializer: ProviderInitializerBuilder<D, S>): ProviderInitializerBuilder<D, S>;
export declare function name<D, S>(name: DependencyName, initializer: ServiceInitializer<D, S>): ServiceInitializer<D, S>;
export declare function name<D, S>(name: DependencyName, initializer: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<D, S>;
/**
 * Decorator to set an initializer name from its function name.
 * @param  {Function}  initializer
 * The initializer to name
 * @return {Function}
 * Returns a new initializer with that name set
 * @example
 *
 * import Knifecycle, { autoName } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(autoName(async function myService() {}));
 */
export declare function autoName<D, S>(initializer: ProviderInitializer<D, S>): ProviderInitializer<D, S>;
export declare function autoName<D, S>(initializer: ProviderInitializerBuilder<D, S>): ProviderInitializerBuilder<D, S>;
export declare function autoName<D, S>(initializer: ServiceInitializer<D, S>): ServiceInitializer<D, S>;
export declare function autoName<D, S>(initializer: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<D, S>;
/**
 * Decorator to set an initializer type.
 * @param  {String}    type
 * The type to set to the initializer.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { name, type } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(
 *   type('service',
 *     name('myService',
 *       myServiceInitializer
 *     )
 *   )
 * );
 */
export declare function type<D, S>(type: 'provider', initializer: ProviderInitializer<D, S>): ProviderInitializer<D, S>;
export declare function type<D, S>(type: 'provider', initializer: ProviderInitializerBuilder<D, S>): ProviderInitializerBuilder<D, S>;
export declare function type<D, S>(type: 'service', initializer: ServiceInitializer<D, S>): ServiceInitializer<D, S>;
export declare function type<D, S>(type: 'service', initializer: ServiceInitializerBuilder<D, S>): ServiceInitializerBuilder<D, S>;
/**
 * Decorator to set an initializer properties.
 * @param  {Object}    properties
 * Properties to set to the service.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns a new initializer
 * @example
 *
 * import Knifecycle, { initializer } from 'knifecycle';
 * import myServiceInitializer from './service';
 *
 * new Knifecycle()
 * .register(initializer({
 *   name: 'myService',
 *   type: 'service',
 *   inject: ['ENV'],
 *   singleton: true,
 * }, myServiceInitializer));
 */
export declare function initializer<D, S>(properties: ProviderInputProperties, initializer: ProviderInitializerBuilder<D, S>): ProviderInitializer<D, S>;
export declare function initializer<D, S>(properties: ServiceInputProperties, initializer: ServiceInitializerBuilder<D, S>): ServiceInitializer<D, S>;
/**
 * Shortcut to create an initializer with a simple handler
 * @param  {Function} handlerFunction
 * The handler function
 * @param  {String}  [name]
 * The name of the handler. Default to the DI prop if exists
 * @param  {Array<String>}  [dependencies=[]]
 * The dependencies to inject in it
 * @param  {Object}    [options]
 * Options attached to the built initializer
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { handler } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(handler(getUser, 'getUser', ['db', '?log']));
 *
 * const QUERY = `SELECT * FROM users WHERE id=$1`
 * async function getUser({ db }, userId) {
 *   const [row] = await db.query(QUERY, userId);
 *
 *   return row;
 * }
 */
export declare function handler<D extends Dependencies, V, P extends Parameters<V>, U extends unknown[], R>(handlerFunction: HandlerFunction<D, V, P, U, R>, name?: ServiceName, dependencies?: DependencyDeclaration[], singleton?: boolean, extra?: ExtraInformations): ServiceInitializer<D, (parameters: P, ...args: U) => Promise<R>>;
/**
 * Allows to create an initializer with a simple handler automagically
 * @param  {Function} handlerFunction
 * The handler function
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { autoHandler } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(autoHandler(getUser));
 *
 * const QUERY = `SELECT * FROM users WHERE id=$1`
 * async function getUser({ db }, userId) {
 *   const [row] = await db.query(QUERY, userId);
 *
 *   return row;
 * }
 */
export declare function autoHandler<D extends Dependencies, V, P extends Parameters<V>, U extends unknown[], R>(handlerFunction: HandlerFunction<D, V, P, U, R>): ServiceInitializer<D, (parameters: P, ...args: U) => Promise<R>>;
/**
 * Explode a dependency declaration an returns its parts.
 * @param  {String}  dependencyDeclaration
 * A dependency declaration string
 * @return {Object}
 * The various parts of it
 * @example
 * parseDependencyDeclaration('pgsql>db');
 * // Returns
 * {
 *   serviceName: 'pgsql',
 *   mappedName: 'db',
 *   optional: false,
 * }
 */
export declare function parseDependencyDeclaration(dependencyDeclaration: DependencyDeclaration): ParsedDependencyDeclaration;
/**
 * Stringify a dependency declaration from its parts.
 * @param  {Object}  dependencyDeclarationParts
 * A dependency declaration string
 * @return {String}
 * The various parts of it
 * @example
 * stringifyDependencyDeclaration({
 *   serviceName: 'pgsql',
 *   mappedName: 'db',
 *   optional: false,
 * });
 *
 * // Returns
 * 'pgsql>db'
 */
export declare function stringifyDependencyDeclaration(dependencyDeclarationParts: ParsedDependencyDeclaration): DependencyDeclaration;
/**
 * Utility function to check and reveal initializer properties.
 * @param  {Function}  initializer
 * The initializer to tweak
 * @return {Function}
 * Returns revealed initializer (with TypeScript types for properties)
 */
export declare function unwrapInitializerProperties<S, D>(initializer: ProviderInitializer<D, S>): ProviderProperties;
export declare function unwrapInitializerProperties<S, D>(initializer: ServiceInitializer<D, S>): ServiceProperties;
export declare function unwrapInitializerProperties<S, D>(initializer: ConstantInitializer<S>): ConstantProperties;
export declare function unwrapInitializerProperties<S, D>(initializer: Initializer<S, D>): InitializerProperties;
