/* eslint @typescript-eslint/ban-types:0 */
import { YError } from 'yerror';
import initDebug from 'debug';
const debug = initDebug('knifecycle');
/* Architecture Note #1.2: Creating initializers

`knifecycle` uses initializers at its a core. An initializer is basically
 an asynchronous function with some annotations:
- name: it uniquely identifies the initializer so that it can be
 referred to as another initializer dependency.
- type: an initializer can be of three types at the moment
 (constant, service or provider). The initializer annotations
 varies accordsing to those types as we'll see later on.
- injected dependencies: an array of dependencies declarations that
 declares which initializer htis initializer depends on. Constants
 logically cannot have dependencies.
- options: various options like for exemple, if the initializer
 implements the singleton pattern or not.
- value: only used for constant, this property allows to know
 the value the initializer resolves to without actually executing it.
- extra: an extra property for custom use that will be propagated
 by the various other decorators you'll find in this library.

`Knifecycle` provides a set of decorators that allows you to simply
 create new initializers.
*/
export const DECLARATION_SEPARATOR = '>';
export const OPTIONAL_FLAG = '?';
export const ALLOWED_INITIALIZER_TYPES = [
    'provider',
    'service',
    'constant',
];
export const SPECIAL_PROPS_PREFIX = '$';
export const SPECIAL_PROPS = {
    TYPE: `${SPECIAL_PROPS_PREFIX}type`,
    NAME: `${SPECIAL_PROPS_PREFIX}name`,
    INJECT: `${SPECIAL_PROPS_PREFIX}inject`,
    SINGLETON: `${SPECIAL_PROPS_PREFIX}singleton`,
    EXTRA: `${SPECIAL_PROPS_PREFIX}extra`,
    VALUE: `${SPECIAL_PROPS_PREFIX}value`,
};
export const ALLOWED_SPECIAL_PROPS = Object.keys(SPECIAL_PROPS).map((key) => SPECIAL_PROPS[key]);
const E_BAD_INJECT_IN_CONSTANT = 'E_BAD_INJECT_IN_CONSTANT';
const E_CONSTANT_INJECTION = 'E_CONSTANT_INJECTION';
export function parseInjections(source, options) {
    const matches = source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\{\s*([^{}]+)(\s*\.\.\.[^{}]+|)\s*\}/);
    if (!matches) {
        if (!source.match(/^\s*async/)) {
            throw new YError('E_NON_ASYNC_INITIALIZER', source);
        }
        if (options &&
            options.allowEmpty &&
            source.match(/^\s*(?:async\s+function(?:\s+\w+)?|async)\s*\(\s*\)/)) {
            return [];
        }
        throw new YError('E_AUTO_INJECTION_FAILURE', source);
    }
    return matches[1]
        .trim()
        .replace(/,$/, '')
        .split(/\s*,\s*/)
        .map((s) => s.trim())
        .filter((s) => !s.startsWith('...'))
        .map((injection) => (injection.includes('=') ? '?' : '') +
        injection.split(/\s*=\s*/).shift().split(/\s*:\s*/).shift())
        .filter((injection) => !/[)(\][]/.test(injection));
}
export function readFunctionName(aFunction) {
    if (typeof aFunction !== 'function') {
        throw new YError('E_AUTO_NAMING_FAILURE', typeof aFunction);
    }
    const functionName = parseName(aFunction.name || '');
    if (!functionName) {
        throw new YError('E_AUTO_NAMING_FAILURE', aFunction.name);
    }
    return functionName;
}
export function parseName(functionName) {
    return functionName.split(' ').pop().replace(/^init(?:ialize)?([A-Z])/, (_, $1) => $1.toLowerCase());
}
export function reuseSpecialProps(from, to, amend = {}) {
    const uniqueInitializer = to.bind(null);
    return [...new Set(Object.keys(from).concat(Object.keys(amend)))]
        .filter((prop) => prop.startsWith(SPECIAL_PROPS_PREFIX))
        .reduce((fn, prop) => {
        const value = 'undefined' !== typeof amend[prop] ? amend[prop] : from[prop];
        if (value instanceof Array) {
            fn[prop] = value.concat();
        }
        else if (value instanceof Object) {
            fn[prop] = Object.assign({}, value);
        }
        else {
            fn[prop] = value;
        }
        return fn;
    }, uniqueInitializer);
}
/**
 * Decorator that creates an initializer for a constant value
 * @param  {String}    name
 * The constant's name.
 * @param  {any}  value
 * The constant's value
 * @return {Function}
 * Returns a new constant initializer
 * @example
 * import Knifecycle, { constant, service } from 'knifecycle';
 *
 * const { printAnswer } = new Knifecycle()
 *   .register(constant('THE_NUMBER', value))
 *   .register(constant('log', console.log.bind(console)))
 *   .register(service(
 *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
 *     'printAnswer',
 *     ['THE_NUMBER', 'log'],
 *   ))
 *   .run(['printAnswer']);
 *
 * printAnswer(); // 42
 */
export function constant(name, value) {
    const contantLooksLikeAnInitializer = value instanceof Function && value[SPECIAL_PROPS.INJECT];
    if (contantLooksLikeAnInitializer) {
        throw new YError(E_CONSTANT_INJECTION, value[SPECIAL_PROPS.INJECT]);
    }
    debug(`Created an initializer from a constant: ${name}.`);
    return {
        $type: 'constant',
        $name: name,
        $singleton: true,
        $value: value,
    };
}
/**
 * Decorator that creates an initializer from a service builder
 * @param  {Function}   serviceBuilder
 * An async function to build the service
 * @param  {String}    [name]
 * The service's name
 * @param  {Array<String>}    [dependencies]
 * The service's injected dependencies
 * @param  {Boolean}    [singleton]
 * Whether the service is a singleton or not
 * @param  {any}    [extra]
 * Eventual extra informations
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { constant, service } from 'knifecycle';
 *
 * const { printAnswer } = new Knifecycle()
 *   .register(constant('THE_NUMBER', value))
 *   .register(constant('log', console.log.bind(console)))
 *   .register(service(
 *     async ({ THE_NUMBER, log }) => () => log(THE_NUMBER),
 *     'printAnswer',
 *     ['THE_NUMBER', 'log'],
 *     true
 *   ))
 *   .run(['printAnswer']);
 *
 * printAnswer(); // 42
 */
export function service(serviceBuilder, name, dependencies, singleton, extra) {
    if (!serviceBuilder) {
        throw new YError('E_NO_SERVICE_BUILDER');
    }
    name = name || serviceBuilder[SPECIAL_PROPS.NAME] || 'anonymous';
    dependencies = dependencies || serviceBuilder[SPECIAL_PROPS.INJECT] || [];
    singleton =
        typeof singleton === 'undefined'
            ? serviceBuilder[SPECIAL_PROPS.SINGLETON] || false
            : singleton;
    extra = extra || serviceBuilder[SPECIAL_PROPS.EXTRA] || [];
    debug(`Created an initializer from a service builder: ${name}.`);
    const uniqueInitializer = reuseSpecialProps(serviceBuilder, serviceBuilder, {
        [SPECIAL_PROPS.TYPE]: 'service',
        [SPECIAL_PROPS.NAME]: name,
        [SPECIAL_PROPS.INJECT]: dependencies,
        [SPECIAL_PROPS.SINGLETON]: singleton,
        [SPECIAL_PROPS.EXTRA]: extra,
    });
    return uniqueInitializer;
}
/**
 * Decorator that creates an initializer from a service
 *  builder by automatically detecting its name
 *  and dependencies
 * @param  {Function}   serviceBuilder
 * An async function to build the service
 * @return {Function}
 * Returns a new initializer
 */
export function autoService(serviceBuilder) {
    const name = readFunctionName(serviceBuilder);
    const source = serviceBuilder.toString();
    const dependencies = parseInjections(source, { allowEmpty: true });
    return service(serviceBuilder, name, dependencies);
}
/**
 * Decorator that creates an initializer for a provider
 *  builder
 * @param  {Function} providerBuilder
 * An async function to build the service provider
 * @param  {String} [name]
 * The service's name
 * @param  {Array<String>} [dependencies]
 * The service's dependencies
 * @param  {Boolean} [singleton]
 * Whether the service is a singleton or not
 * @param  {any} [extra]
 * Eventual extra informations
 * @return {Function}
 * Returns a new provider initializer
 * @example
 *
 * import Knifecycle, { provider } from 'knifecycle'
 * import fs from 'fs';
 *
 * const $ = new Knifecycle();
 *
 * $.register(provider(configProvider, 'config'));
 *
 * async function configProvider() {
 *   return new Promise((resolve, reject) {
 *     fs.readFile('config.js', function(err, data) {
 *       let config;
 *
 *       if(err) {
 *         reject(err);
 *         return;
 *       }
 *
 *       try {
 *         config = JSON.parse(data.toString);
 *       } catch (err) {
 *         reject(err);
 *         return;
 *       }
 *
 *       resolve({
 *         service: config,
 *       });
 *     });
 *   });
 * }
 */
export function provider(providerBuilder, name, dependencies, singleton, extra) {
    if (!providerBuilder) {
        throw new YError('E_NO_PROVIDER_BUILDER');
    }
    name = name || providerBuilder[SPECIAL_PROPS.NAME] || 'anonymous';
    dependencies = dependencies || providerBuilder[SPECIAL_PROPS.INJECT] || [];
    singleton =
        typeof singleton === 'undefined'
            ? providerBuilder[SPECIAL_PROPS.SINGLETON] || false
            : singleton;
    extra = extra || providerBuilder[SPECIAL_PROPS.EXTRA] || [];
    debug(`Created an initializer from a provider builder: ${name || 'anonymous'}.`);
    const uniqueInitializer = reuseSpecialProps(providerBuilder, providerBuilder, {
        [SPECIAL_PROPS.TYPE]: 'provider',
        [SPECIAL_PROPS.NAME]: name,
        [SPECIAL_PROPS.INJECT]: dependencies,
        [SPECIAL_PROPS.SINGLETON]: singleton,
        [SPECIAL_PROPS.EXTRA]: extra,
    });
    return uniqueInitializer;
}
/**
 * Decorator that creates an initializer from a provider
 *  builder by automatically detecting its name
 *  and dependencies
 * @param  {Function}   providerBuilder
 * An async function to build the service provider
 * @return {Function}
 * Returns a new provider initializer
 */
export function autoProvider(providerBuilder) {
    const name = readFunctionName(providerBuilder);
    const source = providerBuilder.toString();
    const dependencies = parseInjections(source, { allowEmpty: true });
    return provider(providerBuilder, name, dependencies);
}
export function wrapInitializer(wrapper, baseInitializer) {
    return reuseSpecialProps(baseInitializer, async (services) => {
        const baseInstance = await baseInitializer(services);
        return wrapper(services, baseInstance);
    });
}
export function inject(dependencies, initializer) {
    if ('constant' === initializer[SPECIAL_PROPS.TYPE]) {
        throw new YError(E_BAD_INJECT_IN_CONSTANT, initializer[SPECIAL_PROPS.NAME], dependencies);
    }
    const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
        [SPECIAL_PROPS.INJECT]: dependencies,
    });
    debug('Wrapped an initializer with dependencies:', dependencies);
    return uniqueInitializer;
}
export function useInject(from, to) {
    return inject(from[SPECIAL_PROPS.INJECT] || [], to);
}
export function mergeInject(from, to) {
    return alsoInject(from[SPECIAL_PROPS.INJECT] || [], to);
}
export function autoInject(initializer) {
    const source = initializer.toString();
    const dependencies = parseInjections(source);
    return inject(dependencies, initializer);
}
export function alsoInject(dependencies, initializer) {
    const currentDependencies = (initializer[SPECIAL_PROPS.INJECT] || []).map(parseDependencyDeclaration);
    const addedDependencies = dependencies.map(parseDependencyDeclaration);
    const dedupedDependencies = currentDependencies
        .filter(({ serviceName }) => {
        const declarationIsOverridden = addedDependencies.some(({ serviceName: addedServiceName }) => {
            return addedServiceName === serviceName;
        });
        return !declarationIsOverridden;
    })
        .concat(addedDependencies.map(({ serviceName, mappedName, optional }) => {
        const isOptionalEverywhere = optional &&
            currentDependencies.every(({ optional, mappedName: addedMappedName }) => {
                return addedMappedName !== mappedName || optional;
            });
        return {
            serviceName,
            mappedName,
            optional: isOptionalEverywhere,
        };
    }))
        .map(stringifyDependencyDeclaration);
    return inject(dedupedDependencies, initializer);
}
export function extra(extraInformations, initializer, merge = false) {
    const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
        [SPECIAL_PROPS.EXTRA]: merge
            ? Object.assign(initializer[SPECIAL_PROPS.EXTRA] || {}, extraInformations)
            : extraInformations,
    });
    debug('Wrapped an initializer with extra informations:', extraInformations);
    return uniqueInitializer;
}
export function singleton(initializer, isSingleton = true) {
    const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
        [SPECIAL_PROPS.SINGLETON]: isSingleton,
    });
    debug('Marked an initializer as singleton:', isSingleton);
    return uniqueInitializer;
}
export function name(name, initializer) {
    const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
        [SPECIAL_PROPS.NAME]: name,
    });
    debug('Wrapped an initializer with a name:', name);
    return uniqueInitializer;
}
export function autoName(initializer) {
    return name(readFunctionName(initializer), initializer);
}
export function type(type, initializer) {
    const uniqueInitializer = reuseSpecialProps(initializer, initializer, {
        [SPECIAL_PROPS.TYPE]: type,
    });
    debug('Wrapped an initializer with a type:', type);
    return uniqueInitializer;
}
export function initializer(properties, initializer) {
    const uniqueInitializer = reuseSpecialProps(initializer, initializer, Object.keys(properties).reduce((finalProperties, property) => {
        const finalProperty = SPECIAL_PROPS_PREFIX + property;
        if (!ALLOWED_SPECIAL_PROPS.includes(finalProperty)) {
            throw new YError('E_BAD_PROPERTY', property);
        }
        finalProperties[finalProperty] = properties[property];
        return finalProperties;
    }, {}));
    debug('Wrapped an initializer with properties:', properties);
    return uniqueInitializer;
}
/**
 * Shortcut to create an initializer with a simple handler
 * @param  {Function} handlerFunction
 * The handler function
 * @param  {String}  [name]
 * The name of the handler. Default to the DI prop if exists
 * @param  {Array<String>}  [dependencies=[]]
 * The dependencies to inject in it
 * @param  {Object}    [options]
 * Options attached to the built initializer
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { handler } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(handler(getUser, 'getUser', ['db', '?log']));
 *
 * const QUERY = `SELECT * FROM users WHERE id=$1`
 * async function getUser({ db }, userId) {
 *   const [row] = await db.query(QUERY, userId);
 *
 *   return row;
 * }
 */
export function handler(handlerFunction, name, dependencies, singleton, extra) {
    name = name || handlerFunction[SPECIAL_PROPS.NAME];
    dependencies = dependencies || handlerFunction[SPECIAL_PROPS.INJECT] || [];
    if (!name) {
        throw new YError('E_NO_HANDLER_NAME', handlerFunction);
    }
    return initializer({
        name,
        type: 'service',
        inject: dependencies,
        singleton,
        extra,
    }, async (dependencies) => handlerFunction.bind(null, dependencies));
}
/**
 * Allows to create an initializer with a simple handler automagically
 * @param  {Function} handlerFunction
 * The handler function
 * @return {Function}
 * Returns a new initializer
 * @example
 * import Knifecycle, { autoHandler } from 'knifecycle';
 *
 * new Knifecycle()
 * .register(autoHandler(getUser));
 *
 * const QUERY = `SELECT * FROM users WHERE id=$1`
 * async function getUser({ db }, userId) {
 *   const [row] = await db.query(QUERY, userId);
 *
 *   return row;
 * }
 */
export function autoHandler(handlerFunction) {
    const name = readFunctionName(handlerFunction);
    const source = handlerFunction.toString();
    const dependencies = parseInjections(source);
    return initializer({
        name,
        type: 'service',
        inject: dependencies,
    }, async (dependencies) => handlerFunction.bind(null, dependencies));
}
/* Architecture Note #1.2.1: Dependencies declaration syntax

The dependencies syntax is of the following form:
 `?serviceName>mappedName`
The `?` flag indicates an optional dependency.
 `>mappedName` is optional and allows to inject
 `mappedName` as `serviceName`.
It allows to write generic services with fixed
 dependencies and remap their name at injection time.
*/
/**
 * Explode a dependency declaration an returns its parts.
 * @param  {String}  dependencyDeclaration
 * A dependency declaration string
 * @return {Object}
 * The various parts of it
 * @example
 * parseDependencyDeclaration('pgsql>db');
 * // Returns
 * {
 *   serviceName: 'pgsql',
 *   mappedName: 'db',
 *   optional: false,
 * }
 */
export function parseDependencyDeclaration(dependencyDeclaration) {
    const optional = dependencyDeclaration.startsWith(OPTIONAL_FLAG);
    const [serviceName, mappedName] = (optional ? dependencyDeclaration.slice(1) : dependencyDeclaration).split(DECLARATION_SEPARATOR);
    return {
        serviceName,
        mappedName: mappedName || serviceName,
        optional,
    };
}
/**
 * Stringify a dependency declaration from its parts.
 * @param  {Object}  dependencyDeclarationParts
 * A dependency declaration string
 * @return {String}
 * The various parts of it
 * @example
 * stringifyDependencyDeclaration({
 *   serviceName: 'pgsql',
 *   mappedName: 'db',
 *   optional: false,
 * });
 *
 * // Returns
 * 'pgsql>db'
 */
export function stringifyDependencyDeclaration(dependencyDeclarationParts) {
    return `${dependencyDeclarationParts.optional ? '?' : ''}${dependencyDeclarationParts.serviceName}${dependencyDeclarationParts.mappedName !==
        dependencyDeclarationParts.serviceName
        ? '>' + dependencyDeclarationParts.mappedName
        : ''}`;
}
export function unwrapInitializerProperties(initializer) {
    if (typeof initializer !== 'function' && typeof initializer !== 'object') {
        throw new YError('E_BAD_INITIALIZER', initializer);
    }
    const properties = initializer;
    if (typeof properties[SPECIAL_PROPS.NAME] !== 'string' ||
        properties[SPECIAL_PROPS.NAME] === '') {
        throw new YError('E_ANONYMOUS_ANALYZER', properties[SPECIAL_PROPS.NAME]);
    }
    if (!ALLOWED_INITIALIZER_TYPES.includes(properties[SPECIAL_PROPS.TYPE])) {
        throw new YError('E_BAD_INITIALIZER_TYPE', initializer[SPECIAL_PROPS.NAME], initializer[SPECIAL_PROPS.TYPE], ALLOWED_INITIALIZER_TYPES);
    }
    if (initializer[SPECIAL_PROPS.NAME] === '$autoload' &&
        !initializer[SPECIAL_PROPS.SINGLETON]) {
        throw new YError('E_BAD_AUTOLOADER', initializer[SPECIAL_PROPS.SINGLETON] || false);
    }
    if (properties[SPECIAL_PROPS.TYPE] === 'constant') {
        if ('undefined' ===
            typeof initializer[SPECIAL_PROPS.VALUE]) {
            throw new YError('E_UNDEFINED_CONSTANT_INITIALIZER', properties[SPECIAL_PROPS.NAME]);
        }
        properties[SPECIAL_PROPS.SINGLETON] = true;
    }
    else {
        if ('undefined' !== typeof initializer[SPECIAL_PROPS.VALUE]) {
            throw new YError('E_BAD_VALUED_NON_CONSTANT_INITIALIZER', initializer[SPECIAL_PROPS.NAME]);
        }
        properties[SPECIAL_PROPS.INJECT] = properties[SPECIAL_PROPS.INJECT] || [];
        properties[SPECIAL_PROPS.SINGLETON] =
            properties[SPECIAL_PROPS.SINGLETON] || false;
        properties[SPECIAL_PROPS.EXTRA] =
            properties[SPECIAL_PROPS.EXTRA] || undefined;
    }
    return initializer;
}
//# sourceMappingURL=util.js.map