import { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, reuseSpecialProps, parseName, name, autoName, inject, useInject, mergeInject, autoInject, alsoInject, type, extra, singleton, initializer, constant, service, autoService, provider, autoProvider, wrapInitializer, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties } from './util.js';
import initInitializerBuilder from './build.js';
import type { ServiceName, Service, Disposer, FatalErrorPromise, Provider, Dependencies, DependencyDeclaration, ExtraInformations, ParsedDependencyDeclaration, ConstantProperties, ConstantInitializer, ProviderInitializerBuilder, ProviderProperties, ProviderInitializer, ProviderInputProperties, ServiceInitializerBuilder, ServiceProperties, ServiceInitializer, ServiceInputProperties, AsyncInitializerBuilder, AsyncInitializer, PartialAsyncInitializer, Initializer, ServiceInitializerWrapper, ProviderInitializerWrapper, HandlerFunction, Parameters } from './util.js';
import type { BuildInitializer } from './build.js';
export type { ServiceName, Service, Disposer, FatalErrorPromise, Provider, Dependencies, DependencyDeclaration, ExtraInformations, ParsedDependencyDeclaration, ConstantProperties, ConstantInitializer, ProviderInitializerBuilder, ProviderProperties, ProviderInitializer, ProviderInputProperties, ServiceInitializerBuilder, ServiceProperties, ServiceInitializer, ServiceInputProperties, AsyncInitializerBuilder, AsyncInitializer, PartialAsyncInitializer, Initializer, ServiceInitializerWrapper, ProviderInitializerWrapper, HandlerFunction, Parameters, BuildInitializer, };
export interface Injector<T extends Record<string, unknown>> {
    (dependencies: DependencyDeclaration[]): Promise<T>;
}
export interface Autoloader<T extends Initializer<unknown, Record<string, unknown>>> {
    (name: DependencyDeclaration): Promise<{
        initializer: T;
        path: string;
    }>;
}
export interface SiloContext<S> {
    name: string;
    servicesDescriptors: Map<DependencyDeclaration, Promise<Provider<S>>>;
    servicesSequence: DependencyDeclaration[][];
    servicesShutdownsPromises: Map<DependencyDeclaration, Promise<void>>;
    errorsPromises: Promise<void>[];
    shutdownPromise?: Promise<void>;
    throwFatalError?: (err: Error) => void;
}
export declare type FatalErrorService = {
    promise: Promise<void>;
};
export declare type InternalDependencies = {
    $dispose: Disposer;
    $autoload: Autoloader<Initializer<unknown, Record<string, unknown>>>;
    $injector: Injector<Record<string, unknown>>;
    $instance: Knifecycle;
    $siloContext: SiloContext<unknown>;
    $fatalError: FatalErrorService;
};
declare class Knifecycle {
    private _silosCounter;
    private _silosContexts;
    private _initializers;
    private _initializerResolvers;
    private _singletonsServicesHandles;
    private _singletonsServicesDescriptors;
    private _singletonsServicesShutdownsPromises;
    private shutdownPromise?;
    /**
     * Create a new Knifecycle instance
     * @return {Knifecycle}
     * The Knifecycle instance
     * @example
     *
     * import Knifecycle from 'knifecycle'
     *
     * const $ = new Knifecycle();
     */
    constructor();
    /**
     * Register an initializer
     * @param  {Function}   initializer
     * An initializer
     * @return {Knifecycle}
     * The Knifecycle instance (for chaining)
     */
    register<T extends Initializer<unknown, any>>(initializer: T): Knifecycle;
    _lookupCircularDependencies(rootServiceName: ServiceName, dependencyDeclaration: DependencyDeclaration, declarationsStacks?: DependencyDeclaration[]): void;
    /**
     * Outputs a Mermaid compatible dependency graph of the declared services.
     * See [Mermaid docs](https://github.com/knsv/mermaid)
     * @param {Object} options
     * Options for generating the graph (destructured)
     * @param {Array<Object>} options.shapes
     * Various shapes to apply
     * @param {Array<Object>} options.styles
     * Various styles to apply
     * @param {Object} options.classes
     * A hash of various classes contents
     * @return {String}
     * Returns a string containing the Mermaid dependency graph
     * @example
     *
     * import Knifecycle, { inject, constant, service } from 'knifecycle';
     * import appInitializer from './app';
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.register(constant('OS', require('os')));
     * $.register(service('app', inject(['ENV', 'OS'], appInitializer)));
     * $.toMermaidGraph();
     *
     * // returns
     * graph TD
     *   app-->ENV
     *   app-->OS
     */
    toMermaidGraph({ shapes, styles, classes, }?: {
        shapes?: MermaidShapes;
        styles?: MermaidStyles;
        classes?: MermaidClasses;
    }): string;
    /**
     * Creates a new execution silo
     * @param  {String[]}   dependenciesDeclarations
     * Service name.
     * @return {Promise}
     * Service descriptor promise
     * @example
     *
     * import Knifecycle, { constant } from 'knifecycle'
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.run(['ENV'])
     * .then(({ ENV }) => {
     *  // Here goes your code
     * })
     */
    run<ID extends Record<string, unknown>>(dependenciesDeclarations: DependencyDeclaration[]): Promise<ID>;
    /**
     * Destroy the Knifecycle instance
     * @return {Promise}
     * Full destruction promise
     * @example
     *
     * import Knifecycle, { constant } from 'knifecycle'
     *
     * const $ = new Knifecycle();
     *
     * $.register(constant('ENV', process.env));
     * $.run(['ENV'])
     * .then(({ ENV }) => {
     *    // Here goes your code
     *
     *    // Finally destroy the instance
     *    $.destroy()
     * })
     */
    destroy(): Promise<void>;
    /**
     * Initialize or return a service descriptor
     * @param  {Object}     siloContext
     * Current execution silo context
     * @param  {String}     serviceName
     * Service name.
     * @param  {Object}     options
     * Options for service retrieval
     * @param  {Boolean}    options.injectorContext
     * Flag indicating the injection were initiated by the $injector
     * @param  {Boolean}    options.autoloading
     * Flag to indicating $autoload dependencies on the fly loading
     * @param  {String}     serviceProvider
     * Service provider.
     * @return {Promise}
     * Service descriptor promise.
     */
    _getServiceDescriptor(siloContext: SiloContext<unknown>, serviceName: ServiceName, { injectorContext, autoloading, }: {
        injectorContext: boolean;
        autoloading: boolean;
    }): Promise<Provider<unknown>>;
    _findInitializer(siloContext: SiloContext<unknown>, serviceName: ServiceName, { injectorContext, autoloading, }: {
        injectorContext: boolean;
        autoloading: boolean;
    }): Promise<ProviderInitializer<Record<string, unknown>, unknown>>;
    _pickupSingletonServiceDescriptorPromise(serviceName: ServiceName): Promise<Provider<unknown>> | void;
    /**
     * Initialize a service descriptor
     * @param  {Object}     siloContext
     * Current execution silo context
     * @param  {String}     serviceName
     * Service name.
     * @param  {Object}     options
     * Options for service retrieval
     * @param  {Boolean}    options.injectorContext
     * Flag indicating the injection were initiated by the $injector
     * @param  {Boolean}    options.autoloading
     * Flag to indicating $autoload dependendencies on the fly loading.
     * @return {Promise}
     * Service dependencies hash promise.
     */
    _initializeServiceDescriptor(siloContext: SiloContext<unknown>, serviceName: ServiceName, initializer: ProviderInitializer<Record<string, unknown>, unknown>, { autoloading, injectorContext, }: {
        autoloading: boolean;
        injectorContext: boolean;
    }): Promise<Provider<unknown>>;
    /**
     * Initialize a service dependencies
     * @param  {Object}     siloContext
     * Current execution silo siloContext
     * @param  {String}     serviceName
     * Service name.
     * @param  {String}     servicesDeclarations
     * Dependencies declarations.
     * @param  {Object}     options
     * Options for service retrieval
     * @param  {Boolean}    options.injectorContext
     * Flag indicating the injection were initiated by the $injector
     * @param  {Boolean}    options.autoloading
     * Flag to indicating $autoload dependendencies on the fly loading.
     * @return {Promise}
     * Service dependencies hash promise.
     */
    _initializeDependencies(siloContext: SiloContext<unknown>, serviceName: ServiceName, servicesDeclarations: DependencyDeclaration[], { injectorContext, autoloading, }: {
        autoloading: boolean;
        injectorContext: boolean;
    }): Promise<Dependencies>;
}
export default Knifecycle;
export { SPECIAL_PROPS, SPECIAL_PROPS_PREFIX, DECLARATION_SEPARATOR, OPTIONAL_FLAG, ALLOWED_INITIALIZER_TYPES, ALLOWED_SPECIAL_PROPS, parseInjections, readFunctionName, parseName, Knifecycle, initializer, name, autoName, type, inject, useInject, mergeInject, autoInject, alsoInject, extra, singleton, reuseSpecialProps, wrapInitializer, constant, service, autoService, provider, autoProvider, handler, autoHandler, parseDependencyDeclaration, stringifyDependencyDeclaration, unwrapInitializerProperties, initInitializerBuilder, };
declare type MermaidShapes = {
    pattern: RegExp;
    template: string;
}[];
declare type MermaidStyles = {
    pattern: RegExp;
    className: string;
}[];
declare type MermaidClasses = {
    [name: string]: string;
};
